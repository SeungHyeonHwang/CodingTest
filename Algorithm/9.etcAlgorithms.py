"""
< 기타 알고리즘 >

1. 소수 (Prime Number)
 - 1보다 큰 자연수 중에서 1과 자기 자신을 제외한 자연수로는 나누어 떨어지지 않는 자연수

* 성능
 - 2부터 X-1까지 모든 자연수에 대해 연산
 - 시간복잡도는 O(X) 

* 약수의 성질
 - 모든 약수는 가운데 약수를 기준으로 곱셈 연산에 대해 대칭을 이룸
 - ex) 16의 약수는 1,2,4,8,16 임
 - 따라서 특정 자연수의 모든 약수를 찾을 대 가운데 약수(제곱근)까지만 확인하면 됨.
 - ex) 16이 2로 나누어 떨어진다는 것은 8로도 나누어 떨어진다는 것 

 * 소수 판별 알고리즘 성능 개선
 - 따라서 약수의 성질을 이용하면, 특정 수의 제곱근 까지만 확인으로도 소수인지 판별 가능.

 * 성능
  - 2부터 X의 제곱근(소수점 이하 무시) 까지 모든 자연수에 대해 연산
  - 시간복잡도는 O(N^(1/2))

 * 에라토스테네스의 체 알고리즘 
 - 특정한 수의 범위안에 존재하는 모든 소수를 찾을때
 
 * 동작 과정
   1) 2부터 N까지의 모든 자연수를 나열
   2) 남은 수 중에서 아직 처리하지 않은 가장 작은 수 i를 찾음
   3) 남은 수 중에서 i의 배수를 모두 제거( i는 제거 X )
   4) 더 이상 반복할 수 없을 때까지 2~3번 과정 반복

 * 성능
  - 시간복잡도는 O(NloglogN)
  - 각 자연수에 대한 소수 여부를 저장해야하므로 메모리가 많이 필요

2. 투 포인터 (Two Pointers)
 - 리스트에 순차적으로 접근해야 할 때 두 점의 위치를 기록하며 처리
 - 예) 특정한 합을 갖는 부분 연속 수열 찾기
 - 완전 탐색시 O(N^2)임. 

 * 동작 과정
   1) 시작점(start)과 끝점(end)이 첫번째 원소의 인덱스(0)을 가리키게함
   2) 현재 부분 합이 M과 같다면, 카운트
   3) 현재 부분 합이 M보다 작다면, end 1증가
   4) 현재 부분 합이 M보다 크거나 같다면, start 1증가
   5) 모든 경우를 확인할 때까지 2~4번 과정 반복

 * 구간 합 (Inerval Sum)
  - 연속으로 나열된 N개의 수가 있을 때 특정 구간 모든 수의 합 계산 
  
"""


n = 5 # 데이터의 개수 N
m = 5 # 찾고자 하는 부분합 M
data = [1, 2, 3, 2, 5] # 전체 수열

count = 0
interval_sum = 0
end = 0

# start를 차례대로 증가시키며 반복
for start in range(n):
    # end를 가능한 만큼 이동시키기
    while interval_sum < m and end < n:
        interval_sum += data[end]
        end += 1
    # 부분합이 m일 때 카운트 증가
    if interval_sum == m:
        count += 1
    interval_sum -= data[start]

print(count)


"""



"""